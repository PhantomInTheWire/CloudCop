package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"cloudcop/api/graph/model"
	"cloudcop/api/internal/awsauth"
	"cloudcop/api/internal/database"
	"cloudcop/api/internal/middleware/auth"
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// VerifyAWSAccount is the resolver for the verifyAwsAccount field.
func (r *mutationResolver) VerifyAWSAccount(ctx context.Context, accountID string, externalID string) (*model.AWSAccount, error) {
	// Verify access via STS AssumeRole
	info, err := r.Auth.VerifyAccountAccess(ctx, awsauth.AssumeRoleInput{
		AccountID:  accountID,
		ExternalID: externalID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to verify account: %w", err)
	}

	// In a real implementation, we would get the Team ID from context or input
	// For now, we stub it or use a default if available.
	// Since the simplified schema doesn't strictly link verify to a team immediately in the mutation signature,
	// we will just return the verified status object.
	// However, we should try to persist this verification state if possible.

	// Create or update account in DB
	// We need a team ID. For now let's assume a default team 1 for the user or pass it.
	// The schema might need adjustment to include teamID, but for now we follow the signature.

	// Stub database insert pending full team flow implementation

	lastVerified := time.Now().Format(time.RFC3339)
	return &model.AWSAccount{
		ID:             "temp-id",
		AccountID:      info.AccountID,
		ExternalID:     externalID,
		Verified:       true,
		RoleArn:        &info.ARN,
		LastVerifiedAt: &lastVerified,
	}, nil
}

// ConnectAccount is the resolver for the connectAccount field.
func (r *mutationResolver) ConnectAccount(ctx context.Context, accountID string, externalID string, roleArn string) (*model.AWSAccount, error) {
	// Satisfy linter by using ctx
	if auth.FromContext(ctx) == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Similar to verify, but persists the connection.
	// We need to know which team this belongs to.
	// user := auth.FromContext(ctx)
	// if user == nil { return nil, fmt.Errorf("unauthorized") }

	// For MVP/Hackathon, we might just assume single team per user or just create one.

	return &model.AWSAccount{
		ID:         "new-id",
		AccountID:  accountID,
		ExternalID: externalID,
		Verified:   true,
		RoleArn:    &roleArn,
	}, nil
}

// StartScan is the resolver for the startScan field.
func (r *mutationResolver) StartScan(ctx context.Context, accountID string, services []string, regions []string) (*database.Scan, error) {
	if auth.FromContext(ctx) == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	// Convert ID
	// dbID, _ := strconv.Atoi(accountID)
	_ = accountID // TODO: Use for database lookup

	// Create Scan record
	// scan, err := r.DB.CreateScan(...)

	// Trigger Logic (Kestra/Go Routines)

	// Return stub
	now := time.Now()
	// Convert time.Time to pgtype.Timestamp
	pgNow := pgtype.Timestamp{Time: now, Valid: true}

	return &database.Scan{
		ID:        1,
		Status:    "pending",
		Services:  services,
		Regions:   regions,
		CreatedAt: pgNow,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*database.User, error) {
	user := auth.FromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Persist user if not exists (upsert)
	email, _ := auth.EmailFromContext(ctx)
	fullName, _ := auth.FullnameFromContext(ctx)

	dbUser, err := r.DB.CreateUser(ctx, database.CreateUserParams{
		ID:    user.ID,
		Email: email,
		Name:  pgtype.Text{String: fullName, Valid: fullName != ""},
	})
	if err != nil {
		return nil, err
	}

	return &database.User{
		ID:        dbUser.ID,
		Email:     dbUser.Email,
		Name:      dbUser.Name,
		CreatedAt: dbUser.CreatedAt,
	}, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, slug string) (*database.Team, error) {
	if auth.FromContext(ctx) == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	_ = slug // TODO: Use for database lookup
	return nil, nil
}

// MyAccounts is the resolver for the myAccounts field.
func (r *queryResolver) MyAccounts(ctx context.Context) ([]model.AWSAccount, error) {
	// Satisfy linter
	_ = ctx
	// Placeholder
	return []model.AWSAccount{}, nil
}

// ID is the resolver for the id field.
func (r *scanResolver) ID(ctx context.Context, obj *database.Scan) (string, error) {
	_ = ctx
	return fmt.Sprintf("%d", obj.ID), nil
}

// OverallScore is the resolver for the overallScore field.
func (r *scanResolver) OverallScore(ctx context.Context, obj *database.Scan) (*int, error) {
	_ = ctx
	if obj.OverallScore.Valid {
		val := int(obj.OverallScore.Int32)
		return &val, nil
	}
	return nil, nil
}

// Findings is the resolver for the findings field.
func (r *scanResolver) Findings(ctx context.Context, obj *database.Scan) ([]model.Finding, error) {
	_ = ctx
	_ = obj
	return []model.Finding{}, nil
}

// Summary is the resolver for the summary field.
func (r *scanResolver) Summary(ctx context.Context, obj *database.Scan) (*model.ScanSummary, error) {
	// TODO: Implement summary retrieval from database or cache
	// For now, return nil as summaries are generated on-demand during scan
	_ = ctx
	_ = obj
	return nil, nil
}

// StartedAt is the resolver for the startedAt field.
func (r *scanResolver) StartedAt(ctx context.Context, obj *database.Scan) (*string, error) {
	_ = ctx
	if obj.StartedAt.Valid {
		s := obj.StartedAt.Time.Format(time.RFC3339)
		return &s, nil
	}
	return nil, nil
}

// CompletedAt is the resolver for the completedAt field.
func (r *scanResolver) CompletedAt(ctx context.Context, obj *database.Scan) (*string, error) {
	_ = ctx
	if obj.CompletedAt.Valid {
		s := obj.CompletedAt.Time.Format(time.RFC3339)
		return &s, nil
	}
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *scanResolver) CreatedAt(ctx context.Context, obj *database.Scan) (string, error) {
	_ = ctx
	if obj.CreatedAt.Valid {
		return obj.CreatedAt.Time.Format(time.RFC3339), nil
	}
	return "", nil
}

// ID is the resolver for the id field.
func (r *teamResolver) ID(ctx context.Context, obj *database.Team) (string, error) {
	_ = ctx
	return fmt.Sprintf("%d", obj.ID), nil
}

// Members is the resolver for the members field.
func (r *teamResolver) Members(ctx context.Context, obj *database.Team) ([]database.TeamMember, error) {
	_ = ctx
	_ = obj
	return []database.TeamMember{}, nil
}

// AWSAccounts is the resolver for the awsAccounts field.
func (r *teamResolver) AWSAccounts(ctx context.Context, obj *database.Team) ([]model.AWSAccount, error) {
	_ = ctx
	_ = obj
	return []model.AWSAccount{}, nil
}

// User is the resolver for the user field.
func (r *teamMemberResolver) User(ctx context.Context, obj *database.TeamMember) (*database.User, error) {
	_ = ctx
	_ = obj
	return nil, nil
}

// Name is the resolver for the name field.
func (r *userResolver) Name(ctx context.Context, obj *database.User) (*string, error) {
	_ = ctx
	if obj.Name.Valid {
		return &obj.Name.String, nil
	}
	return nil, nil
}

// Teams is the resolver for the teams field.
func (r *userResolver) Teams(ctx context.Context, obj *database.User) ([]database.Team, error) {
	_ = ctx
	_ = obj
	return []database.Team{}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Scan returns ScanResolver implementation.
func (r *Resolver) Scan() ScanResolver { return &scanResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

// TeamMember returns TeamMemberResolver implementation.
func (r *Resolver) TeamMember() TeamMemberResolver { return &teamMemberResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type scanResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
type teamMemberResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
