package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"cloudcop/api/graph/model"
	"cloudcop/api/internal/awsauth"
	"cloudcop/api/internal/database"
	"cloudcop/api/internal/middleware/auth"
	"cloudcop/api/internal/scanner"
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

// VerifyAWSAccount is the resolver for the verifyAwsAccount field.
func (r *mutationResolver) VerifyAWSAccount(ctx context.Context, accountID string, externalID string) (*model.AWSAccount, error) {
	// Verify access via STS AssumeRole
	info, err := r.Auth.VerifyAccountAccess(ctx, awsauth.AssumeRoleInput{
		AccountID:  accountID,
		ExternalID: externalID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to verify account: %w", err)
	}

	// In a real implementation, we would get the Team ID from context or input
	// For now, we stub it or use a default if available.
	// Since the simplified schema doesn't strictly link verify to a team immediately in the mutation signature,
	// we will just return the verified status object.
	// However, we should try to persist this verification state if possible.

	// Create or update account in DB
	// We need a team ID. For now let's assume a default team 1 for the user or pass it.
	// The schema might need adjustment to include teamID, but for now we follow the signature.

	// Stub database insert pending full team flow implementation

	lastVerified := time.Now().Format(time.RFC3339)
	return &model.AWSAccount{
		ID:             "temp-id",
		AccountID:      info.AccountID,
		ExternalID:     externalID,
		Verified:       true,
		RoleArn:        &info.ARN,
		LastVerifiedAt: &lastVerified,
	}, nil
}

// ConnectAccount is the resolver for the connectAccount field.
func (r *mutationResolver) ConnectAccount(ctx context.Context, accountID string, externalID string, roleArn string) (*model.AWSAccount, error) {
	// Satisfy linter by using ctx
	if auth.FromContext(ctx) == nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Similar to verify, but persists the connection.
	// We need to know which team this belongs to.
	// user := auth.FromContext(ctx)
	// if user == nil { return nil, fmt.Errorf("unauthorized") }

	// For MVP/Hackathon, we might just assume single team per user or just create one.

	return &model.AWSAccount{
		ID:         "new-id",
		AccountID:  accountID,
		ExternalID: externalID,
		Verified:   true,
		RoleArn:    &roleArn,
	}, nil
}

// StartScan is the resolver for the startScan field.
func (r *mutationResolver) StartScan(ctx context.Context, accountID string, services []string, regions []string) (*database.Scan, error) {
	// For E2E tests, we might bypass auth or assume it's set.
	// if auth.FromContext(ctx) == nil { return nil, fmt.Errorf("unauthorized") }

	// Run Scan Synchronously for Demo
	// Note: In production, this should be async via Kestra
	if r.Security == nil {
		return nil, fmt.Errorf("security service not initialized")
	}

	result, err := r.Security.Scan(ctx, scanner.ScanConfig{
		AccountID: accountID,
		Regions:   regions,
		Services:  services,
	})
	if err != nil {
		return nil, fmt.Errorf("scan failed: %w", err)
	}

	// Generate ID
	scanID := int32(time.Now().Unix())

	// Store result in ephemeral cache
	r.ScanResults.Store(fmt.Sprintf("%d", scanID), result)

	// Return DB model stub
	now := time.Now()
	var score int32
	if result.Summary != nil {
		score = int32(result.Summary.RiskScore)
	}

	return &database.Scan{
		ID:        scanID,
		Status:    "completed",
		Services:  services,
		Regions:   regions,
		CreatedAt: pgtype.Timestamp{Time: now, Valid: true},
		OverallScore: pgtype.Int4{
			Int32: score,
			Valid: result.Summary != nil,
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*database.User, error) {
	user := auth.FromContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("not authenticated")
	}

	// Persist user if not exists (upsert)
	email, _ := auth.EmailFromContext(ctx)
	fullName, _ := auth.FullnameFromContext(ctx)

	dbUser, err := r.DB.CreateUser(ctx, database.CreateUserParams{
		ID:    user.ID,
		Email: email,
		Name:  pgtype.Text{String: fullName, Valid: fullName != ""},
	})
	if err != nil {
		return nil, err
	}

	return &database.User{
		ID:        dbUser.ID,
		Email:     dbUser.Email,
		Name:      dbUser.Name,
		CreatedAt: dbUser.CreatedAt,
	}, nil
}

// Team is the resolver for the team field.
func (r *queryResolver) Team(ctx context.Context, slug string) (*database.Team, error) {
	if auth.FromContext(ctx) == nil {
		return nil, fmt.Errorf("unauthorized")
	}
	_ = slug
	return nil, nil
}

// MyAccounts is the resolver for the myAccounts field.
func (r *queryResolver) MyAccounts(ctx context.Context) ([]model.AWSAccount, error) {
	// Satisfy linter
	_ = ctx
	// Placeholder
	return []model.AWSAccount{}, nil
}

// ID is the resolver for the id field.
func (r *scanResolver) ID(ctx context.Context, obj *database.Scan) (string, error) {
	_ = ctx
	return fmt.Sprintf("%d", obj.ID), nil
}

// OverallScore is the resolver for the overallScore field.
func (r *scanResolver) OverallScore(ctx context.Context, obj *database.Scan) (*int, error) {
	_ = ctx
	if obj.OverallScore.Valid {
		val := int(obj.OverallScore.Int32)
		return &val, nil
	}
	return nil, nil
}

// Findings is the resolver for the findings field.
func (r *scanResolver) Findings(ctx context.Context, obj *database.Scan) ([]model.Finding, error) {
	_ = ctx
	_ = obj
	return []model.Finding{}, nil
}

// Summary is the resolver for the summary field.
func (r *scanResolver) Summary(ctx context.Context, obj *database.Scan) (*model.ScanSummary, error) {
	_ = ctx
	id := fmt.Sprintf("%d", obj.ID)
	val, ok := r.ScanResults.Load(id)
	if !ok {
		return nil, nil
	}
	result := val.(*scanner.ScanResultWithSummary)
	if result.Summary == nil {
		return nil, nil
	}

	return mapScanSummary(result.Summary), nil
}

func mapScanSummary(s *scanner.ScanSummary) *model.ScanSummary {
	if s == nil {
		return nil
	}
	groups := make([]model.FindingGroupSummary, len(s.Groups))
	for i, g := range s.Groups {
		groups[i] = model.FindingGroupSummary{
			GroupID:      g.GroupID,
			Title:        g.Title,
			Service:      g.Service,
			CheckID:      g.CheckID,
			Severity:     g.Severity,
			FindingCount: g.FindingCount,
			ResourceIds:  g.ResourceIDs,
			Summary:      g.Summary,
			Remedy:       g.Remedy,
		}
	}

	actions := make([]model.ActionItemSummary, len(s.Actions))
	for i, a := range s.Actions {
		actions[i] = model.ActionItemSummary{
			ActionID:    a.ActionID,
			Title:       a.Title,
			Description: a.Description,
			Severity:    a.Severity,
			Commands:    a.Commands,
			GroupID:     a.GroupID,
		}
	}

	return &model.ScanSummary{
		RiskLevel:   s.RiskLevel,
		RiskScore:   s.RiskScore,
		SummaryText: s.SummaryText,
		Groups:      groups,
		Actions:     actions,
	}
}

// StartedAt is the resolver for the startedAt field.
func (r *scanResolver) StartedAt(ctx context.Context, obj *database.Scan) (*string, error) {
	_ = ctx
	if obj.StartedAt.Valid {
		s := obj.StartedAt.Time.Format(time.RFC3339)
		return &s, nil
	}
	return nil, nil
}

// CompletedAt is the resolver for the completedAt field.
func (r *scanResolver) CompletedAt(ctx context.Context, obj *database.Scan) (*string, error) {
	_ = ctx
	if obj.CompletedAt.Valid {
		s := obj.CompletedAt.Time.Format(time.RFC3339)
		return &s, nil
	}
	return nil, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *scanResolver) CreatedAt(ctx context.Context, obj *database.Scan) (string, error) {
	_ = ctx
	if obj.CreatedAt.Valid {
		return obj.CreatedAt.Time.Format(time.RFC3339), nil
	}
	return "", nil
}

// ID is the resolver for the id field.
func (r *teamResolver) ID(ctx context.Context, obj *database.Team) (string, error) {
	_ = ctx
	return fmt.Sprintf("%d", obj.ID), nil
}

// Members is the resolver for the members field.
func (r *teamResolver) Members(ctx context.Context, obj *database.Team) ([]database.TeamMember, error) {
	_ = ctx
	_ = obj
	return []database.TeamMember{}, nil
}

// AWSAccounts is the resolver for the awsAccounts field.
func (r *teamResolver) AWSAccounts(ctx context.Context, obj *database.Team) ([]model.AWSAccount, error) {
	_ = ctx
	_ = obj
	return []model.AWSAccount{}, nil
}

// User is the resolver for the user field.
func (r *teamMemberResolver) User(ctx context.Context, obj *database.TeamMember) (*database.User, error) {
	_ = ctx
	_ = obj
	return nil, nil
}

// Name is the resolver for the name field.
func (r *userResolver) Name(ctx context.Context, obj *database.User) (*string, error) {
	_ = ctx
	if obj.Name.Valid {
		return &obj.Name.String, nil
	}
	return nil, nil
}

// Teams is the resolver for the teams field.
func (r *userResolver) Teams(ctx context.Context, obj *database.User) ([]database.Team, error) {
	_ = ctx
	_ = obj
	return []database.Team{}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Scan returns ScanResolver implementation.
func (r *Resolver) Scan() ScanResolver { return &scanResolver{r} }

// Team returns TeamResolver implementation.
func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

// TeamMember returns TeamMemberResolver implementation.
func (r *Resolver) TeamMember() TeamMemberResolver { return &teamMemberResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type scanResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
type teamMemberResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
